{"version":3,"file":"preview-ZE6RrxMB.js","sources":["../../src/dom-node-safe-guards.ts","../../src/config.ts","../../src/queries.ts","../../src/utils.ts","../../src/interceptors.ts","../../src/capture-announcements.ts","../../.storybook/pretty-dom-with-shadow-dom.ts","../../.storybook/preview.ts"],"sourcesContent":["/*\n * This file is mostly to avoid circular dependencies\n */\n\nexport function isElement(node: Node | null): node is Element {\n    return node != null && node.nodeType === Node.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(node: Node | null): node is ShadowRoot {\n    return node != null && node instanceof ShadowRoot;\n}\n\nexport function isDocument(node: Node | null): node is Document {\n    return node != null && node.nodeType === Node.DOCUMENT_NODE;\n}\n","interface Config {\n    /** Indicates whether live regions inside `ShadowRoot`s should be tracked */\n    includeShadowDom?: boolean;\n}\n\nlet config: Config = {\n    includeShadowDom: false,\n};\n\n/**\n * Configure global options\n */\nexport function configure(newConfig: Config | Partial<Config>): void {\n    config = {\n        ...config,\n        ...newConfig,\n    };\n}\n\n/**\n * Get global options\n */\nexport function getConfig(): Config {\n    return config;\n}\n","import { getConfig } from './config';\nimport { isDocument, isElement, isShadowRoot } from './dom-node-safe-guards';\n\n/**\n * `Element.closest` which traverses tree up when `ShadowRoot` is encountered\n */\nexport function closest(\n    element: Element,\n    ...args: Parameters<Element['closest']>\n): ReturnType<Element['closest']> {\n    const result = element.closest(...args);\n\n    if (result || !getConfig().includeShadowDom) {\n        return result;\n    }\n\n    const rootNode = element.getRootNode();\n\n    if (isShadowRoot(rootNode)) {\n        return closest(rootNode.host, ...args);\n    }\n\n    return null;\n}\n\n/**\n * `Node.parentNode` as method which traverses tree up when `ShadowRoot` is encountered\n */\nexport function getParentNode(node: Node): Node['parentNode'] {\n    if (node.parentNode || !getConfig().includeShadowDom) {\n        return node.parentNode;\n    }\n\n    if (isShadowRoot(node)) {\n        return node.host;\n    }\n\n    return null;\n}\n\n/**\n * `Node.childNodes` as method which traverses tree down when `ShadowRoot` is encountered\n */\nexport function getChildNodes(node: Node): Node['childNodes'] {\n    if (getConfig().includeShadowDom && isElement(node) && node.shadowRoot) {\n        return getChildNodes(node.shadowRoot);\n    }\n\n    return node.childNodes;\n}\n\n/**\n * `querySelectorAll` which includes all contents of all `ShadowRoot`'s.\n * Note that return type is directly `Element[]` instead of `NodeListOf`.\n */\nexport function querySelectorAll(\n    context: Document | Element,\n    ...args: Parameters<(typeof context)['querySelectorAll']>\n): Element[] {\n    if (!getConfig().includeShadowDom) {\n        return Array.from(context.querySelectorAll(...args));\n    }\n\n    const roots = [context, ...findShadowRoots([context])];\n\n    return roots.reduce<Element[]>(\n        (all, root) => [...all, ...root.querySelectorAll(...args)],\n        []\n    );\n}\n\n/**\n * Finds `ShadowRoot`'s and their nested `ShadowRoot`'s\n * - This is highly inspired by Cypress: https://github.com/cypress-io/cypress/blob/develop/packages/driver/src/dom/elements/shadow.ts\n */\nfunction findShadowRoots(\n    nodes: Node[],\n    shadowRoots: ShadowRoot[] = []\n): ShadowRoot[] {\n    if (nodes.length === 0) return shadowRoots;\n\n    // Find new nested shadow roots\n    const rootsFromThisLevel = nodes.reduce<ShadowRoot[]>(\n        (all, node) => [...all, ...findShadowRootsOfNode(node)],\n        []\n    );\n\n    // Check whether newly found shadow roots have nested shadow roots\n    return findShadowRoots(rootsFromThisLevel, [\n        ...shadowRoots,\n        ...rootsFromThisLevel,\n    ]);\n}\n\n/**\n * Finds all `ShadowRoot`'s of given node. Does not traverse nested `ShadowRoot`'s.\n */\nfunction findShadowRootsOfNode(root: Node): ShadowRoot[] {\n    const doc = root.getRootNode({ composed: true });\n    const shadowRoots: ShadowRoot[] = [];\n\n    if (!isDocument(doc)) return shadowRoots;\n\n    if (isElement(root) && root.shadowRoot) {\n        shadowRoots.push(root.shadowRoot);\n    }\n\n    const treeWalker = doc.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_DOCUMENT_FRAGMENT,\n        { acceptNode: acceptNodesWithShadowRoot }\n    );\n\n    function collectRoots(roots: ShadowRoot[]): ShadowRoot[] {\n        const nextNode = treeWalker.nextNode();\n\n        if (!isElement(nextNode)) return roots;\n        if (!nextNode.shadowRoot) return roots;\n\n        return collectRoots([...roots, nextNode.shadowRoot]);\n    }\n\n    return collectRoots(shadowRoots);\n}\n\nfunction acceptNodesWithShadowRoot(node: Node): number {\n    if (isElement(node) && node.shadowRoot) {\n        return NodeFilter.FILTER_ACCEPT;\n    }\n\n    return NodeFilter.FILTER_SKIP;\n}\n","import { isElement } from './dom-node-safe-guards';\nimport * as queries from './queries';\n\nexport type PolitenessSetting = 'polite' | 'assertive' | 'off';\n\nconst LIVE_REGION_ROLES = ['status', 'log', 'alert'] as const;\ntype LiveRegionRole = (typeof LIVE_REGION_ROLES)[number];\n\nconst LIVE_REGION_QUERY = [\n    '[role=\"status\"]',\n    '[role=\"log\"]',\n    '[role=\"alert\"]',\n    '[aria-live=\"polite\"]',\n    '[aria-live=\"assertive\"]',\n    'output',\n\n    // Roles with implicit aria-live=\"off\"\n    // '[role=\"marquee\"]',\n    // '[role=\"timer\"]',\n].join(', ');\n\nconst HIDDEN_QUERY = '[aria-hidden=\"true\"]';\n\nexport function getAllLiveRegions(context: Document | Element): Element[] {\n    const liveRegions = queries.querySelectorAll(context, LIVE_REGION_QUERY);\n\n    // Check whether given `context` is also a live region\n    if (\n        isElement(context) &&\n        resolvePolitenessSetting(context) !== 'off' &&\n        isInDOM(context)\n    ) {\n        return liveRegions.concat(context).filter(filterUnique);\n    }\n\n    return liveRegions;\n}\n\nexport function getClosestElement(node: Node): Element | null {\n    if (isElement(node)) {\n        return node;\n    }\n\n    const parentNode = queries.getParentNode(node);\n\n    if (parentNode) {\n        return getClosestElement(parentNode);\n    }\n\n    return null;\n}\n\nexport function isLiveRegionAttribute(\n    attribute: string\n): attribute is LiveRegionRole | PolitenessSetting {\n    return (\n        LIVE_REGION_ROLES.includes(attribute as LiveRegionRole) ||\n        isPolitenessSetting(attribute)\n    );\n}\n\nexport function isInDOM(node: Node): boolean {\n    const element = getClosestElement(node);\n\n    return element != null && queries.closest(element, 'html') != null;\n}\n\n// TODO: Support `hidden` and CSS attributes:\n// https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-hidden_attribute#best_practices\nexport function isHidden(node: Node): boolean {\n    const element = getClosestElement(node);\n\n    if (!element) return true;\n\n    if (element.getAttribute('aria-hidden') === 'true') {\n        return true;\n    }\n\n    if (element.getAttribute('aria-live') === 'off') {\n        return true;\n    }\n\n    const role = element.getAttribute('role');\n    if (role === 'marquee' || role === 'timer') {\n        return true;\n    }\n\n    return queries.closest(element, HIDDEN_QUERY) != null;\n}\n\nexport function getClosestLiveRegion(element: Element | null): Element | null {\n    return element ? queries.closest(element, LIVE_REGION_QUERY) : null;\n}\n\nfunction isPolitenessSetting(\n    setting: string | null\n): setting is PolitenessSetting {\n    return setting === 'polite' || setting === 'assertive' || setting === 'off';\n}\n\n/**\n * Resolve politeness setting of given node\n * - Recursively traverse tree up until live region is found\n */\nexport function resolvePolitenessSetting(node: Node | null): PolitenessSetting {\n    if (!node || !isElement(node)) return 'off';\n\n    const ariaLive = node.getAttribute('aria-live');\n    if (isPolitenessSetting(ariaLive)) return ariaLive;\n\n    const role = node.getAttribute('role');\n    if (role === 'marquee' || role === 'timer') return 'off';\n    if (role === 'status' || role === 'log') return 'polite';\n    if (role === 'alert') return 'assertive';\n\n    if (node.tagName.toLowerCase() === 'output') {\n        return 'polite';\n    }\n\n    const closestLiveRegion = getClosestLiveRegion(node);\n\n    // Element.closest may return itself. Find the closest parent.\n    if (closestLiveRegion === node) {\n        return resolvePolitenessSetting(\n            getClosestLiveRegion(node.parentElement)\n        );\n    }\n\n    return resolvePolitenessSetting(closestLiveRegion);\n}\n\nconst WHITE_SPACE_REGEXP = /\\s+/g;\n\nexport function trimWhiteSpace(text: string): string | null {\n    const trimmed = text.trim().replace(WHITE_SPACE_REGEXP, ' ');\n    return trimmed.length > 0 ? trimmed : null;\n}\n\n/**\n * Get text content of a `Node`\n */\nexport function getTextContent(node: Node | null): string | null {\n    if (!node) return null;\n    if (isHidden(node)) return null;\n\n    if (node.nodeType === Node.TEXT_NODE) {\n        return node.textContent ? trimWhiteSpace(node.textContent) : null;\n    }\n\n    const childNodes = queries.getChildNodes(node);\n    if (childNodes.length === 0) return null;\n\n    const textContent = Array.from(childNodes)\n        .map(getTextContent)\n        .filter(Boolean)\n        .join(' ');\n\n    return trimWhiteSpace(textContent);\n}\n\nfunction filterUnique<T>(item: T, index: number, array: T[]): boolean {\n    return array.indexOf(item) === index;\n}\n","export type Restore = () => void;\n\n/** Indicates whether interception should happen before or after the original method calling */\ntype ExecutionOrder = 'BEFORE' | 'AFTER';\n\n/**\n * Intercept objects setters of property\n * - Original setter is invoked first\n */\nexport function interceptSetter<\n    T extends Object = Object,\n    P extends keyof T = keyof T,\n    K extends T[P] = T[P],\n>(obj: T, property: P, method: (value: K) => void): Restore {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, property);\n\n    if (!descriptor || !descriptor.set) {\n        throw new Error(\n            `Unable to intercept ${String(property)}. No descriptor available.`\n        );\n    }\n\n    const originalSetter = descriptor.set;\n\n    descriptor.set = function interceptedSet(value: K) {\n        const output = originalSetter.call(this, value);\n        method.call(this, value);\n\n        return output;\n    };\n\n    Object.defineProperty(obj, property, descriptor);\n\n    return function restore() {\n        descriptor.set = originalSetter;\n        Object.defineProperty(obj, property, descriptor);\n    };\n}\n\n/**\n * Intercept method calls of given object\n * - Original method is invoked first by default\n */\nexport function interceptMethod<\n    T extends Object = Object,\n    P extends keyof T = keyof T,\n>(\n    object: T,\n    methodName: P,\n    method: (...args: any[]) => void,\n    order: ExecutionOrder = 'AFTER'\n): Restore {\n    const original = object[methodName] as unknown as Function;\n\n    if (typeof original !== 'function') {\n        throw new Error(\n            `Expected ${String(\n                methodName\n            )} to be a function. Received ${typeof original}: ${original}`\n        );\n    }\n\n    if (typeof method !== 'function') {\n        throw new Error(\n            `Expected method to be a function. Received ${typeof method}: ${method}`\n        );\n    }\n\n    function interceptedMethod(this: T, ...args: any) {\n        if (order === 'BEFORE') {\n            method.call(this, ...args);\n        }\n\n        const output = original.call(this, ...args);\n\n        if (order === 'AFTER') {\n            method.call(this, ...args);\n        }\n\n        return output;\n    }\n\n    object[methodName] = interceptedMethod as any;\n\n    return function restore() {\n        object[methodName] = original as any;\n    };\n}\n","import {\n    getAllLiveRegions,\n    getClosestElement,\n    getClosestLiveRegion,\n    getTextContent,\n    isHidden,\n    isInDOM,\n    isLiveRegionAttribute,\n    PolitenessSetting,\n    resolvePolitenessSetting,\n    trimWhiteSpace,\n} from './utils';\nimport { interceptMethod, interceptSetter, Restore } from './interceptors';\nimport { isElement } from './dom-node-safe-guards';\nimport { configure } from './config';\n\ninterface Options {\n    /** Callback invoked when announcement is captured */\n    onCapture: (\n        textContent: string,\n        politenessSetting: Exclude<PolitenessSetting, 'off'>\n    ) => void;\n\n    /** Indicates whether live regions inside `ShadowRoot`s should be tracked */\n    includeShadowDom?: boolean;\n}\n\n// Map of live regions to previous textContent\nconst liveRegions = new Map<Node, string | null>();\n\nexport default function CaptureAnnouncements(options: Options): Restore {\n    configure({ includeShadowDom: options.includeShadowDom || false });\n\n    const onCapture: Options['onCapture'] = (\n        textContent,\n        politenessSetting\n    ) => {\n        const content = trimWhiteSpace(textContent);\n\n        if (content) {\n            options.onCapture(content, politenessSetting);\n        }\n    };\n\n    /**\n     * Check whether given node should trigger announcement\n     * - Node should be inside live region\n     * - Politeness setting should not be off\n     * - `textContent` of live region should have changed\n     */\n    function updateAnnouncements(node: Node) {\n        if (liveRegions.size === 0) return;\n\n        const element = getClosestElement(node);\n        if (!element) return;\n\n        const liveRegion = getClosestLiveRegion(element);\n\n        if (liveRegion) {\n            const politenessSetting = resolvePolitenessSetting(liveRegion);\n\n            if (politenessSetting !== 'off' && isInDOM(liveRegion)) {\n                const previousText = liveRegions.get(liveRegion);\n                const newText = getTextContent(liveRegion) || '';\n\n                // Update text content when element disappears inside live region\n                if (isHidden(element)) {\n                    if (previousText) {\n                        liveRegions.set(liveRegion, newText);\n                    }\n                    return;\n                }\n\n                if (previousText !== newText) {\n                    onCapture(newText, politenessSetting);\n                    liveRegions.set(liveRegion, newText);\n                }\n            }\n        }\n    }\n\n    function addLiveRegion(liveRegion: Element) {\n        if (liveRegions.has(liveRegion)) return;\n        if (isHidden(liveRegion)) return;\n\n        const politenessSetting = resolvePolitenessSetting(liveRegion);\n        if (politenessSetting === 'off') return;\n\n        const textContent = getTextContent(liveRegion);\n        liveRegions.set(liveRegion, textContent);\n\n        // Content of role=\"alert\" regions are announced on initial mount\n        if (textContent) {\n            if (liveRegion.getAttribute('role') === 'alert') {\n                onCapture(textContent, politenessSetting);\n            }\n        }\n    }\n\n    /**\n     * Check DOM for live regions and update `liveRegions` store\n     * - TODO: Could be optimized based on appended/updated child\n     */\n    function updateLiveRegions(node: Node) {\n        const context = isElement(node) ? node : document;\n\n        for (const liveRegion of getAllLiveRegions(context)) {\n            addLiveRegion(liveRegion);\n        }\n    }\n\n    function onTextContentChange(this: Node) {\n        updateAnnouncements(this);\n    }\n\n    function onNodeValueChange(this: Node) {\n        updateAnnouncements(this);\n    }\n\n    /**\n     * Shared handler for methods which mount new nodes on DOM, e.g. appendChild, insertBefore\n     */\n    function onNodeMount(node: Node) {\n        updateLiveRegions(node);\n        updateAnnouncements(node);\n    }\n\n    function onInsertAdjacent(this: Node) {\n        onNodeMount(this);\n    }\n\n    function onSetAttribute(\n        this: Element,\n        ...args: Parameters<Element['setAttribute']>\n    ): void {\n        if (!isElement(this)) return;\n        if (!isInDOM(this)) return;\n        if (!args[0]) return;\n\n        const [attribute] = args;\n\n        switch (attribute) {\n            case 'role':\n            case 'aria-live': {\n                const isAlreadyTracked = liveRegions.has(this);\n                const liveRegionAttribute = isLiveRegionAttribute(args[1]);\n\n                // Attribute value was changed from live region attribute to something else.\n                // Stop tracking this element.\n                if (isAlreadyTracked && !liveRegionAttribute) {\n                    liveRegions.delete(this);\n                    return;\n                }\n\n                // Previous value was not live region attribute value\n                if (!isAlreadyTracked && liveRegionAttribute) {\n                    return updateLiveRegions(this);\n                }\n\n                // Value was changed to assertive - announce content immediately\n                if (\n                    isAlreadyTracked &&\n                    liveRegionAttribute &&\n                    resolvePolitenessSetting(this) === 'assertive'\n                ) {\n                    return updateAnnouncements(this);\n                }\n                break;\n            }\n\n            case 'aria-hidden': {\n                updateLiveRegions(this);\n                return updateAnnouncements(this);\n            }\n\n            default:\n                return;\n        }\n    }\n\n    function onRemoveAttributeAfter(\n        this: Element,\n        ...args: Parameters<Element['removeAttribute']>\n    ) {\n        if (!isElement(this)) return;\n\n        // Note that at this point we are not 100% sure the removed attribute\n        // actually existed on the node. Do not make assumptions based on that\n        // here, e.g. no blindly removing the node from tracked nodes.\n        const [attribute] = args;\n\n        if (attribute === 'aria-hidden') {\n            updateLiveRegions(this);\n            updateAnnouncements(this);\n        }\n    }\n\n    function onRemoveChild(\n        this: Element,\n        ...args: Parameters<Element['removeChild']>\n    ) {\n        if (liveRegions.size === 0) return;\n\n        const [node] = args;\n\n        if (node == null || !isElement(node)) {\n            return updateAnnouncements(this);\n        }\n\n        const elementAndItsLiveRegionChildren = [\n            node,\n            ...getAllLiveRegions(node),\n        ];\n\n        // Check whether removed element or any of its children were tracked\n        for (const element of elementAndItsLiveRegionChildren) {\n            if (liveRegions.has(element)) {\n                liveRegions.delete(element);\n            }\n        }\n\n        updateAnnouncements(this);\n    }\n\n    // prettier-ignore\n    const cleanups: Restore[] = [\n        interceptMethod(DocumentFragment.prototype, 'removeChild', onRemoveChild),\n        interceptMethod(DocumentFragment.prototype, 'replaceChildren', onNodeMount),\n        interceptMethod(DocumentFragment.prototype, 'append', onNodeMount),\n        interceptMethod(DocumentFragment.prototype, 'prepend', onNodeMount),\n\n        interceptMethod(Element.prototype, 'setAttribute', onSetAttribute),\n        interceptMethod(Element.prototype, 'removeAttribute', onRemoveAttributeBefore, 'BEFORE'),\n        interceptMethod(Element.prototype, 'removeAttribute', onRemoveAttributeAfter, 'AFTER'),\n        interceptMethod(Element.prototype, 'removeChild', onRemoveChild),\n        interceptMethod(Element.prototype, 'replaceChildren', onNodeMount),\n        interceptMethod(Element.prototype, 'insertAdjacentElement', onInsertAdjacent),\n        interceptMethod(Element.prototype, 'insertAdjacentHTML', onInsertAdjacent),\n        interceptMethod(Element.prototype, 'insertAdjacentText', onInsertAdjacent),\n        interceptMethod(Element.prototype, 'before', onNodeMount),\n        interceptMethod(Element.prototype, 'append', onNodeMount),\n        interceptMethod(Element.prototype, 'prepend', onNodeMount),\n\n        interceptMethod(Node.prototype, 'appendChild', onNodeMount),\n        interceptMethod(Node.prototype, 'insertBefore', onNodeMount),\n        interceptMethod(Node.prototype, 'replaceChild', onNodeMount),\n        interceptSetter(Node.prototype, 'textContent', onTextContentChange),\n        interceptSetter(Node.prototype, 'nodeValue', onNodeValueChange)\n    ];\n\n    // Initialize live regions which are already in DOM\n    updateLiveRegions(document);\n\n    return function restore() {\n        cleanups.splice(0).forEach(cleanup => cleanup());\n        liveRegions.clear();\n    };\n}\n\nfunction onRemoveAttributeBefore(\n    this: Element,\n    ...args: Parameters<Element['removeAttribute']>\n) {\n    if (liveRegions.size === 0) return;\n    if (!isElement(this)) return;\n\n    const [attribute] = args;\n\n    // Element must have the attribute about to be removed\n    if (!this.hasAttribute(attribute)) return;\n\n    // TODO: Should detect if we have role AND aria-live, and one is removed.\n    if (attribute === 'role' || attribute === 'aria-live') {\n        // Live region attribute is removed -> Element is no longer a live region\n        if (liveRegions.has(this)) {\n            liveRegions.delete(this);\n        }\n    }\n}\n\n/** Not part of public API, do not use */\nexport const __PrivateUnstableAPI = {\n    liveRegions,\n};\n","/*\n * Copy of `@testing-library/dom`'s `DOMElementFilter.ts` with slight modifications\n * to include `ShadowRoot`s contents in output of `prettyDOM` calls.\n *\n * https://github.com/testing-library/dom-testing-library/blob/main/src/DOMElementFilter.ts\n */\n\nimport { prettyDOM, type prettyFormat } from '@testing-library/dom';\n\nexport default function prettyDOMWithShadowDOM(\n    ...args: Parameters<typeof prettyDOM>\n): ReturnType<typeof prettyDOM> {\n    const [dom, maxLength, options] = args;\n\n    const plugin: prettyFormat.NewPlugin = {\n        test: (val: any) => val?.constructor?.name && testNode(val),\n        serialize,\n    };\n\n    return prettyDOM(dom, maxLength, {\n        ...options,\n        plugins: [plugin as any],\n        filterNode: () => true,\n    });\n}\n\nfunction escapeHTML(str: string): string {\n    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\n// Return empty string if keys is empty.\nfunction printProps(\n    keys: Array<string>,\n    props: Record<string, unknown>,\n    config: prettyFormat.Config,\n    indentation: string,\n    depth: number,\n    refs: prettyFormat.Refs,\n    printer: prettyFormat.Printer\n): string {\n    const indentationNext = indentation + config.indent;\n    const colors = config.colors;\n    return keys\n        .map(key => {\n            const value = props[key];\n            let printed = printer(value, config, indentationNext, depth, refs);\n\n            if (typeof value !== 'string') {\n                if (printed.indexOf('\\n') !== -1) {\n                    printed =\n                        config.spacingOuter +\n                        indentationNext +\n                        printed +\n                        config.spacingOuter +\n                        indentation;\n                }\n                printed = '{' + printed + '}';\n            }\n\n            return (\n                config.spacingInner +\n                indentation +\n                colors.prop.open +\n                key +\n                colors.prop.close +\n                '=' +\n                colors.value.open +\n                printed +\n                colors.value.close\n            );\n        })\n        .join('');\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\nconst NodeTypeTextNode = 3;\n\n// Return empty string if children is empty.\nconst printChildren = (\n    children: Array<unknown>,\n    config: prettyFormat.Config,\n    indentation: string,\n    depth: number,\n    refs: prettyFormat.Refs,\n    printer: prettyFormat.Printer\n): string =>\n    children\n        .map(child => {\n            const printedChild =\n                typeof child === 'string'\n                    ? printText(child, config)\n                    : printer(child, config, indentation, depth, refs);\n\n            if (\n                printedChild === '' &&\n                typeof child === 'object' &&\n                child !== null &&\n                (child as Node).nodeType !== NodeTypeTextNode\n            ) {\n                // A plugin serialized this Node to '' meaning we should ignore it.\n                return '';\n            }\n            return config.spacingOuter + indentation + printedChild;\n        })\n        .join('');\n\nconst printText = (text: string, config: prettyFormat.Config): string => {\n    const contentColor = config.colors.content;\n    return contentColor.open + escapeHTML(text) + contentColor.close;\n};\n\nconst printComment = (comment: string, config: prettyFormat.Config): string => {\n    const commentColor = config.colors.comment;\n    return (\n        commentColor.open +\n        '<!--' +\n        escapeHTML(comment) +\n        '-->' +\n        commentColor.close\n    );\n};\n\n// Separate the functions to format props, children, and element,\n// so a plugin could override a particular function, if needed.\n// Too bad, so sad: the traditional (but unnecessary) space\n// in a self-closing tagColor requires a second test of printedProps.\nconst printElement = (\n    type: string,\n    printedProps: string,\n    printedChildren: string,\n    hasShadowRoot: boolean,\n    config: prettyFormat.Config,\n    indentation: string\n): string => {\n    const tagColor = config.colors.tag;\n    const shadowRootMarkup = hasShadowRoot\n        ? `${config.spacingOuter + indentation}  #shadow-root`\n        : '';\n\n    return (\n        tagColor.open +\n        '<' +\n        type +\n        (printedProps &&\n            tagColor.close +\n                printedProps +\n                config.spacingOuter +\n                indentation +\n                tagColor.open) +\n        (printedChildren\n            ? '>' +\n              shadowRootMarkup +\n              tagColor.close +\n              printedChildren +\n              config.spacingOuter +\n              indentation +\n              tagColor.open +\n              '</' +\n              type\n            : (printedProps && !config.min ? '' : ' ') + '/') +\n        '>' +\n        tagColor.close\n    );\n};\n\nconst printElementAsLeaf = (\n    type: string,\n    config: prettyFormat.Config\n): string => {\n    const tagColor = config.colors.tag;\n    return (\n        tagColor.open +\n        '<' +\n        type +\n        tagColor.close +\n        ' …' +\n        tagColor.open +\n        ' />' +\n        tagColor.close\n    );\n};\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst FRAGMENT_NODE = 11;\n\nconst ELEMENT_REGEXP = /^((HTML|SVG)\\w*)?Element$/;\n\nconst testNode = (val: any) => {\n    const constructorName = val.constructor.name;\n    const { nodeType, tagName } = val;\n    const isCustomElement =\n        (typeof tagName === 'string' && tagName.includes('-')) ||\n        (typeof val.hasAttribute === 'function' && val.hasAttribute('is'));\n\n    return (\n        (nodeType === ELEMENT_NODE &&\n            (ELEMENT_REGEXP.test(constructorName) || isCustomElement)) ||\n        (nodeType === TEXT_NODE && constructorName === 'Text') ||\n        (nodeType === COMMENT_NODE && constructorName === 'Comment') ||\n        (nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment')\n    );\n};\n\ntype HandledType = Element | Text | Comment | DocumentFragment;\n\nfunction nodeIsText(node: HandledType): node is Text {\n    return node.nodeType === TEXT_NODE;\n}\n\nfunction nodeIsComment(node: HandledType): node is Comment {\n    return node.nodeType === COMMENT_NODE;\n}\n\nfunction nodeIsFragment(node: HandledType): node is DocumentFragment {\n    return node.nodeType === FRAGMENT_NODE;\n}\n\nfunction serialize(\n    node: HandledType,\n    config: prettyFormat.Config,\n    indentation: string,\n    depth: number,\n    refs: prettyFormat.Refs,\n    printer: prettyFormat.Printer\n): string {\n    if (nodeIsText(node)) {\n        return printText(node.data, config);\n    }\n\n    if (nodeIsComment(node)) {\n        return printComment(node.data, config);\n    }\n\n    const type = nodeIsFragment(node)\n        ? `DocumentFragment`\n        : node.tagName.toLowerCase();\n\n    if (++depth > config.maxDepth) {\n        return printElementAsLeaf(type, config);\n    }\n\n    const children = printChildren(\n        getChildren(node),\n        config,\n        indentation + config.indent,\n        depth,\n        refs,\n        printer\n    );\n\n    const hasShadowRoot = 'shadowRoot' in node && node.shadowRoot != null;\n\n    return printElement(\n        type,\n        printProps(\n            nodeIsFragment(node)\n                ? []\n                : Array.from(node.attributes)\n                      .map(attr => attr.name)\n                      .sort(),\n            nodeIsFragment(node)\n                ? {}\n                : Array.from(node.attributes).reduce<Record<string, string>>(\n                      (props, attribute) => {\n                          props[attribute.name] = attribute.value;\n                          return props;\n                      },\n                      {}\n                  ),\n            config,\n            indentation + config.indent,\n            depth,\n            refs,\n            printer\n        ),\n        children,\n        hasShadowRoot,\n        config,\n        indentation\n    );\n}\n\nfunction getChildren(node: Element | DocumentFragment): Node[] {\n    const shadowRoot = node instanceof Element && node.shadowRoot;\n\n    const nodes = [node, shadowRoot].filter(Boolean) as Element[];\n\n    const children = nodes.reduce(\n        (all, current) => [...all, ...(current.childNodes || current.children)],\n        [] as Node[]\n    );\n\n    return children;\n}\n","import { addons } from '@storybook/addons';\nimport { STORY_CHANGED } from '@storybook/core-events';\nimport { expect } from '@storybook/jest';\nimport { within } from '@storybook/testing-library';\n\nimport CaptureAnnouncements from '../src';\nimport prettyDOMWithShadowDOM from './pretty-dom-with-shadow-dom';\nimport { AnnouncementEvents, SourceCodeUpdateEvents } from './utils';\n\ntype StoryFn = () => HTMLElement;\n\nCaptureAnnouncements({\n    onCapture: (text, level) => AnnouncementEvents.emit({ text, level }),\n    includeShadowDom: true,\n});\n\naddons.getChannel().addListener(STORY_CHANGED, () => {\n    // Reset captures after a story changes\n    AnnouncementEvents.clear();\n});\n\nexport const decorators = [\n    function withSourceCode(Story: StoryFn) {\n        const html = Story();\n        const sourceCodeFrame = document.createElement('div');\n        const sourceCodeId = 'source-code-frame';\n        const storyTargetId = 'story-target-source-code-frame';\n\n        sourceCodeFrame.innerHTML = `\n            <div style=\"display: flex; flex-direction: row; align-content: baseline;\">\n                <div id=\"${storyTargetId}\" style=\"flex-basis: 50%;\"></div>\n                <pre id=\"${sourceCodeId}\" aria-live=\"off\" aria-hidden=\"true\" style=\"flex-basis: 50%; margin: 0; background-color: #eee; padding: 0.5rem;\"></pre>\n            </div>\n        `.trim();\n\n        function updateSourceCodeFrame() {\n            const code = compose(\n                escapeHTML,\n                formatSourceCode,\n                prettyDOMWithShadowDOM\n            )(html);\n\n            const frame = sourceCodeFrame.querySelector(`#${sourceCodeId}`);\n            if (!frame) throw new Error(`Unable to find ${sourceCodeId}`);\n            frame.innerHTML = code;\n        }\n\n        SourceCodeUpdateEvents.on(updateSourceCodeFrame);\n        updateSourceCodeFrame();\n\n        const storyTarget = sourceCodeFrame.querySelector(`#${storyTargetId}`);\n        if (!storyTarget) throw new Error(`Unable to find ${storyTargetId}`);\n        storyTarget.appendChild(html);\n\n        return sourceCodeFrame;\n    },\n\n    function withFocusTarget(Story: StoryFn) {\n        const wrapper = document.createElement('div');\n        const focusTarget = document.createElement('a');\n        focusTarget.setAttribute('tabindex', '0');\n        focusTarget.setAttribute('href', 'javascript:void(0)');\n        focusTarget.setAttribute(\n            'style',\n            'display: inline-block; margin-bottom: 2rem;'\n        );\n        focusTarget.textContent = 'Focus target';\n\n        wrapper.appendChild(focusTarget);\n        wrapper.appendChild(Story());\n\n        setTimeout(() => focusTarget.focus(), 1000);\n\n        return wrapper;\n    },\n\n    function withAnnouncements(Story: StoryFn) {\n        const html = Story();\n        const announcementsFrame = document.createElement('div');\n        const announcementsId = 'announcements-frame';\n        const storyTargetId = 'story-target-announcement-frame';\n\n        announcementsFrame.innerHTML = `\n            <div style=\"display: flex; flex-direction: column; align-content: baseline;\">\n                <div id=\"${storyTargetId}\" style=\"flex-basis: 50%;\"></div>\n\n                <div aria-live=\"off\" aria-hidden=\"true\" style=\"flex-basis: 50%; margin-top: 5rem; background-color: #eee; padding: 0 1rem\">\n                    <h2>Captured announcements</h2>\n                    <ul id=\"${announcementsId}\" style=\"padding-left: 0 1rem;\"></ul>\n                </div>\n            </div>\n        `.trim();\n\n        AnnouncementEvents.on(({ text, level }) => {\n            const li = document.createElement('li');\n            li.textContent = `${level}: ${text}`;\n\n            const list = announcementsFrame.querySelector(\n                `#${announcementsId}`\n            );\n            if (!list) throw new Error(`Unable to find ${announcementsId}`);\n            list.appendChild(li);\n        });\n\n        const storyTarget = announcementsFrame.querySelector(\n            `#${storyTargetId}`\n        );\n        if (!storyTarget) throw new Error(`Unable to find ${storyTargetId}`);\n        storyTarget.appendChild(html);\n\n        return announcementsFrame;\n    },\n];\n\nfunction escapeHTML(str: string) {\n    return str.replace(\n        /[&<>'\"]/g,\n        tag =>\n            // @ts-expect-error -- umm...\n            ({\n                '&': '&amp;',\n                '<': '&lt;',\n                '>': '&gt;',\n                \"'\": '&#39;',\n                '\"': '&quot;',\n            })[tag]\n    );\n}\n\nfunction formatSourceCode(str: string) {\n    return (\n        str\n            // Remove double line breaks\n            .replace(/\\n +\\n/g, '\\n')\n\n            // Remove parent div\n            .replace(/(^<div>\\n|\\n<\\/div>$)/g, '')\n\n            // Remove one level of indention\n            .replace(/^ {2}/g, '')\n            .replace(/\\n {2}/g, '\\n')\n\n            // Add newline between each root level element\n            .replace(/(>\\n)(<\\w)/g, '$1\\n$2')\n\n            // Replace self-ending tags with starting and ending tags\n            .replace(/( *)<(\\w+)((\\s|\\w|=|\"|-)*)\\s*\\/>/g, '$1<$2 $3>\\n$1</$2>')\n\n            // Align attributes to same level as tag when there is only a single attribute\n            .replace(/<(\\w+) *\\n +((\\w|=|\"|-)+)\\n *>/g, '<$1 $2>')\n\n            // Remove spaces before end tag\n            .replace(/ +>/g, '>')\n    );\n}\n\nconst compose = (...fns: any[]) =>\n    fns.reduceRight(\n        (prevFn, nextFn) =>\n            (...args: any[]) =>\n                nextFn(prevFn(...args)),\n        (value: any) => value\n    );\n\nexpect.extend({\n    toBeAnnounced: function toBeAnnounced(\n        this: { isNot?: boolean },\n        text: string,\n        politenessSetting?: 'assertive' | 'polite'\n    ) {\n        const container = within(document.body).getByRole('heading', {\n            name: 'Captured announcements',\n            hidden: true,\n        }).parentElement;\n\n        if (!container) {\n            return {\n                pass: false,\n                message: () => 'Unable to find announcements container',\n            };\n        }\n\n        const [element] = within(container).queryAllByText(\n            `${politenessSetting}: ${text}`\n        );\n\n        const pass = element != null;\n\n        if (pass) {\n            return {\n                pass,\n                message: () =>\n                    `Expected announcement \"${text}\" not to be done, but it was.`,\n            };\n        }\n\n        return {\n            pass,\n            message: () =>\n                `Expected announcement \"${text}\" to be done, but it was not.`,\n        };\n    },\n});\n"],"names":["isElement","node","__name","isShadowRoot","isDocument","config","configure","newConfig","getConfig","closest","element","args","result","rootNode","getParentNode","getChildNodes","querySelectorAll","context","findShadowRoots","all","root","nodes","shadowRoots","rootsFromThisLevel","findShadowRootsOfNode","doc","treeWalker","acceptNodesWithShadowRoot","collectRoots","roots","nextNode","LIVE_REGION_ROLES","LIVE_REGION_QUERY","HIDDEN_QUERY","getAllLiveRegions","liveRegions","queries.querySelectorAll","resolvePolitenessSetting","isInDOM","filterUnique","getClosestElement","parentNode","queries.getParentNode","isLiveRegionAttribute","attribute","isPolitenessSetting","queries.closest","isHidden","role","getClosestLiveRegion","setting","ariaLive","closestLiveRegion","WHITE_SPACE_REGEXP","trimWhiteSpace","text","trimmed","getTextContent","childNodes","queries.getChildNodes","textContent","item","index","array","interceptSetter","obj","property","method","descriptor","originalSetter","value","output","interceptMethod","object","methodName","order","original","interceptedMethod","CaptureAnnouncements","options","onCapture","politenessSetting","content","updateAnnouncements","liveRegion","previousText","newText","addLiveRegion","updateLiveRegions","onTextContentChange","onNodeValueChange","onNodeMount","onInsertAdjacent","onSetAttribute","isAlreadyTracked","liveRegionAttribute","onRemoveAttributeAfter","onRemoveChild","elementAndItsLiveRegionChildren","cleanups","onRemoveAttributeBefore","cleanup","prettyDOMWithShadowDOM","dom","maxLength","prettyDOM","val","_a","testNode","serialize","escapeHTML","str","printProps","keys","props","indentation","depth","refs","printer","indentationNext","colors","key","printed","NodeTypeTextNode","printChildren","children","child","printedChild","printText","contentColor","printComment","comment","commentColor","printElement","type","printedProps","printedChildren","hasShadowRoot","tagColor","shadowRootMarkup","printElementAsLeaf","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","FRAGMENT_NODE","ELEMENT_REGEXP","constructorName","nodeType","tagName","isCustomElement","nodeIsText","nodeIsComment","nodeIsFragment","getChildren","attr","shadowRoot","current","addons","STORY_CHANGED","level","AnnouncementEvents","decorators","Story","html","sourceCodeFrame","sourceCodeId","storyTargetId","updateSourceCodeFrame","code","compose","formatSourceCode","frame","SourceCodeUpdateEvents","storyTarget","wrapper","focusTarget","announcementsFrame","announcementsId","li","list","tag","fns","prevFn","nextFn","expect","container","within","pass"],"mappings":"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"}